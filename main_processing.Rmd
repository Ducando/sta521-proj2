---
title: "521 Project 2"
output: html_document
---

```{r setup, include=FALSE, warning = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)

library(tidyverse)
library(viridis)
library(GGally)
source("CVmaster.R")

# graph theme object 
theme_settings <- theme_light() + theme(axis.text = element_text(size=8), axis.title = element_text(size = 9), legend.title = element_text(size = 9), plot.title = element_text(size = 10, hjust = 0.5)) 
```

## Section 1 

&nbsp; 

```{r}
# read in files with column names 
names <- c("y_coord", "x_coord", "expert", "ndai", "sd", "corr", "angle_df", 
           "angle_cf", "angle_bf", "angle_af", "angle_an")

imagem1 <- read.table('./data/imagem1.txt', col.names = names)
imagem2 <- read.table('./data/imagem2.txt', col.names = names)
imagem3 <- read.table('./data/imagem3.txt', col.names = names)


# make expert column factor and text version
imagem1 %>%
  mutate(expert = as.factor(expert)) %>%
  mutate(expert_text = ifelse(expert == 0, "unlabeled", ifelse(expert == 1, "cloudy","clear"))) -> imagem1

imagem2 %>%
  mutate(expert = as.factor(expert)) %>%
  mutate(expert_text = ifelse(expert == 0, "unlabeled", ifelse(expert == 1, "cloudy","clear"))) -> imagem2

imagem3 %>%
  mutate(expert = as.factor(expert)) %>%
  mutate(expert_text = ifelse(expert == 0, "unlabeled", ifelse(expert == 1, "cloudy","clear"))) -> imagem3

imagem1 %>%
  bind_rows(imagem2) %>%
  bind_rows(imagem3) -> all

```

&nbsp; 

#### Part B

&nbsp; 

```{r}
# look at percentage for total 
all %>%
  group_by(expert_text) %>%
  summarise(prop_total = round((n() / 345556),2))

# look at percentage for each one 
len1 <- nrow(imagem1)
imagem1 %>%
  group_by(expert_text) %>%
  summarise(prop_total = round((n() / len1),2))

len2 <- nrow(imagem2)
imagem2 %>%
  group_by(expert_text) %>%
  summarise(prop_total = round((n() / len2),2))

len3 <- nrow(imagem3)
imagem3 %>%
  group_by(expert_text) %>%
  summarise(prop_total = round((n() / len3),2))
```


```{r}

# We might want to change the colors here becuase it's hard to distinguish between the blue and the black on the legend

# Image 1
ggplot(imagem1, aes(x = x_coord, y = y_coord, color = expert_text)) + 
  geom_point() + 
  theme_settings + 
  labs(x = "X Coordinate", y = "Y Coordinate", color = "Expert Labels") +
  scale_colour_manual(values = c("darkblue", "black", "lightgrey"))

# Image 2
ggplot(imagem2, aes(x = x_coord, y = y_coord, color = expert_text)) + 
  geom_point() + 
  theme_settings + 
  labs(x = "X Coordinate", y = "Y Coordinate", color = "Expert Labels") +
  scale_colour_manual(values = c("darkblue", "black", "lightgrey"))

# Image 3
ggplot(imagem3, aes(x = x_coord, y = y_coord, color = expert_text)) + 
  geom_point() + 
  theme_settings + 
  labs(x = "X Coordinate", y = "Y Coordinate", color = "Expert Labels") +
  scale_colour_manual(values = c("darkblue", "black", "lightgrey"))
```

&nbsp; 

#### Part C

&nbsp; 

```{r}
# pairwise relationships between features 
# cor(all$ndai, all$corr)

all %>%
  select(ndai:angle_an) %>%
  ggpairs()
```

```{r}
# looking at al the angles 
# all %>%
#   select(angle_df:angle_an) %>%
#   ggpairs()
```


```{r}
# expert labels vs features 
imagem1 %>%
  filter(expert != 0) %>%
  ggplot(aes(x = ndai, fill= expert)) +
  geom_histogram()

imagem1 %>%
  filter(expert != 0) %>%
  ggplot(aes(x = corr, fill= expert)) +
  geom_histogram()

imagem1 %>%
  filter(expert != 0) %>%
  ggplot(aes(x = sd, fill= expert)) +
  geom_histogram()

imagem1 %>%
  filter(expert != 0) %>%
  ggplot(aes(x = angle_df, fill= expert)) +
  geom_histogram()

imagem1 %>%
  filter(expert != 0) %>%
  ggplot(aes(x = angle_cf, fill= expert)) +
  geom_histogram()

imagem1 %>%
  filter(expert != 0) %>%
  ggplot(aes(x = angle_bf, fill= expert)) +
  geom_histogram()

imagem1 %>%
  filter(expert != 0) %>%
  ggplot(aes(x = angle_af, fill= expert)) +
  geom_histogram()

imagem1 %>%
  filter(expert != 0) %>%
  ggplot(aes(x = angle_an, fill= expert)) +
  geom_histogram()
```


## Section 2

#### Part A

```{r}
set.seed(513)
images <- list(imagem1,imagem2,imagem3)
indices <- sample(1:3)
train_image <- images[[indices[1]]]
val_image <- images[[indices[2]]]
test_image <- images[[indices[3]]]
```

```{r}
find_blocks <- function(x, y, num_blocks) {
  n <- sqrt(num_blocks)
  x_min <- min(x)
  x_max <- max(x)
  x_step <- (x_max-x_min)/n
  
  y_min <- min(y)
  y_max <- max(y)
  y_step <- (y_max-y_min)/n
  
  block <- tibble()
  names(block) <- c("top", "bottom", "left", "right")
  
  for (i in seq_len(n)) {
    # make top and bottom
    top <- floor(y_min + (i-1) * y_step)
    bot <- floor(y_max - (n-i) * y_step )
    if (i != n)
      bot <- bot - 1
    
    for (j in seq_len(n)){
      # make left and right 
      left <- floor(x_min + (j-1) * x_step)
      right <- floor(x_max - (n-j) * x_step )
      if (j != n)
        right <- right - 1
      
      block %>%
        bind_rows(data.frame(top, bot, left, right)) -> block 
    }
  }
  
  return(block)
}

# this is going to return overlapping intervals, so will need x >= top and x < bot, etc. 
```



```{r}
split_blocks <- function(block, num_blocks, train_num_blocks, val_num_blocks) {
  set.seed(513)
  train_index <- sample(seq_len(num_blocks),train_num_blocks)
  set.seed(513)
  val_index <- sample(setdiff(seq_len(num_blocks),train_index),val_num_blocks)
  test_index <- setdiff(seq_len(num_blocks), c(train_index,val_index))
  
  train_blocks <- block[train_index,]
  val_blocks <- block[val_index,]
  test_blocks <- block[test_index,]
  
  return(list(train = train_blocks, val = val_blocks, test = test_blocks))
}
```

```{r}
split_data <- function(data, block) {
  final_data <- tibble()
  for (i in seq_len(nrow(block))) {
    coords <- block[i,]
    
    data %>%
      filter(x_coord >= coords$left, x_coord <= coords$right,
            y_coord >= coords$top, y_coord <= coords$bot) -> filtered_data
        
    final_data <- rbind(final_data, filtered_data)
  }
  
  return(final_data)
}
```


```{r}
process_data_main <- function(df, num_blocks, train_num_blocks, val_num_blocks) {
  blocks <- find_blocks(df$x_coord, df$y_coord, num_blocks)
  block_indices <- split_blocks(blocks, num_blocks, train_num_blocks, val_num_blocks)
  
  val <- split_data(df, block_indices$val)
  test <- split_data(df, block_indices$test)
  train <- split_data(df, block_indices$train)

  return(list(val = val, test = test, train = train))
}
```


```{r}
image1_dfs <- process_data_main(imagem1, 9, 5, 2)
image1_test <- image1_dfs$test
image1_train <- image1_dfs$train
image1_val <- image1_dfs$val

image2_dfs <- process_data_main(imagem2, 9, 5, 2)
image2_test <- image2_dfs$test
image2_train <- image2_dfs$train
image2_val <- image2_dfs$val

image3_dfs <- process_data_main(imagem3, 9, 5, 2)
image3_test <- image3_dfs$test
image3_train <- image3_dfs$train
image3_val <- image3_dfs$val

train <- image1_train %>%
  bind_rows(image2_train) %>%
  bind_rows(image3_train)

test <- image1_test%>%
  bind_rows(image2_test) %>%
  bind_rows(image3_test)

val <- image1_val%>%
  bind_rows(image2_val) %>%
  bind_rows(image3_val)

# 345556
# nrow(train) + nrow(test) + nrow(val)
```

#### Part B
```{r}
val %>%
  filter(expert != 0)%>%
  summarise(mean(expert == -1))
test %>%
  filter(expert != 0)%>%
  summarise(mean(expert == -1))
```
  
This classifier will have high average accuracy when the image is mostly cloud free.

#### Part C
```{r}
all %>%
  select(ndai:angle_an) %>%
  cor(.,as.integer(all$expert))
```
```{r}
imagem1 %>%
  filter(expert != 0) %>%
  ggplot(aes(x = sd, fill= expert)) +
  geom_histogram()
```
    
NDAI and CORR are selected as best features becuase they have the highest correlation values with the expert labels. SD is also selected because the range of values between the cloudy and cloud free data is more separable than the range of values for the angles.

#### Part D
See the CVmaster.R script.

## Section 1 

#### Part A

```{r}
X_train_image <- train_image %>%
  bind_rows(val_image) %>%
  filter(expert != 0) %>%
  select(ndai,sd,corr)
y_train_image  <- train_image %>%
  bind_rows(val_image) %>%
  filter(expert!=0) %>%
  .$expert %>%
  droplevels()
```


```{r}
X_train_blocks <- train %>%
  bind_rows(val) %>%
  filter(expert != 0) %>%
  select(ndai,sd,corr)
y_train_blocks  <- train %>%
  bind_rows(val) %>%
  filter(expert!=0) %>%
  .$expert %>%
  droplevels()
```

```{r}
image_lda_accuracy <- CVmaster("lda", X_train_image , y_train_image ,10,"accuracy")
image_lda_accuracy
mean(image_lda_accuracy)
```

```{r}
block_lda_accuracy <- CVmaster("lda", X_train_blocks , y_train_blocks ,10,"accuracy")
block_lda_accuracy
mean(block_lda_accuracy)
```

```{r}
image_qda_accuracy <- CVmaster("qda", X_train_image , y_train_image ,10,"accuracy")
image_qda_accuracy
mean(image_qda_accuracy)
```

```{r}
block_qda_accuracy <- CVmaster("qda", X_train_blocks , y_train_blocks ,10,"accuracy")
block_qda_accuracy
mean(block_qda_accuracy)
```

```{r}
image_log_accuracy <- CVmaster("logistic", X_train_image , y_train_image ,10,"accuracy")
image_log_accuracy
mean(image_log_accuracy)
```

```{r}
block_log_accuracy <- CVmaster("logistic", X_train_blocks , y_train_blocks ,10,"accuracy")
block_log_accuracy
mean(block_log_accuracy)
```

```{r}
# This takes too long, need to edit CVmaster to change number of trees
image_rf_accuracy <- CVmaster("rf", X_train_image , y_train_image ,10,"accuracy")
image_rf_accuracy
mean(image_rf_accuracy)
```

```{r}
# This takes too long, need to edit CVmaster to change number of trees
block_rf_accuracy <- CVmaster("rf", X_train_blocks , y_train_blocks ,10,"accuracy")
block_rf_accuracy
mean(block_rf_accuracy)
```
















